<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ORDINARY TECHNOLOGY ACCESS PANEL</title>
    <!-- Add a base URL tag to help with path resolution -->
    <base href="https://partlydecent.github.io/GAMEHUBORDINARY/" />
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet" />
    <!-- Use absolute path for CSS -->
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <canvas id="webglCanvas"></canvas>
    <div class="grid"></div>
    <div class="container">
        <h1>ORDINARY TECHNOLOGY ACCESS PANEL</h1>
        <h1>BUILDING THE FUTURE</h1>
        <div class="beta">BETA</div>
        <div class="button-container">
            <button class="play-button" onclick="navigateToGame()">
                ENTER DIMENSION
            </button>
            <button class="play-button" onclick="navigateToVideoPlayer()">
                WATCH VIDEOS
            </button>
            <button class="play-button" onclick="navigateToLiquidMusic()">
                LIQUID MUSIC
            </button>
            <button class="play-button" onclick="navigateToDimension88()">
                DIMENSION 88
            </button>
            <button class="ai-button" onclick="navigateToAI()">AI</button>
        </div>
    </div>
    <div class="console">
        <input type="text" id="consoleInput" placeholder="ENTER COMMAND..." onkeydown="handleConsoleInput(event)" />
    </div>

    <script>
        // Preload audio to avoid issues
        const warpSound = new Audio('https://partlydecent.github.io/GAMEHUBORDINARY/warp_sound.mp3');
        warpSound.load(); // Preload the audio

        const webglCanvas = document.getElementById('webglCanvas');
        webglCanvas.width = window.innerWidth;
        webglCanvas.height = window.innerHeight;
        const gl = webglCanvas.getContext('webgl');

        if (!gl) {
            alert("WebGL not supported in this browser.");
        }

        // Vertex shader source
        const vertexShaderSource = `
      attribute vec4 a_position;
      void main() {
        gl_Position = a_position;
      }
    `;

        // Fragment shader source (initial, will be updated)
        let fragmentShaderSource = `
      precision mediump float;
      uniform float u_time;
      void main() {
        vec2 uv = gl_FragCoord.xy / vec2(800.0, 600.0);
        float color = sin(u_time + uv.x * 10.0) * 0.5 + 0.5;
        gl_FragColor = vec4(color, color, color, 1.0);
      }
    `;

        // Function to create and compile a shader
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Function to create a program
        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        // Initialize shaders and program
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        let fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        let program = createProgram(gl, vertexShader, fragmentShader);

        // Look up attribute and uniform locations
        let positionAttributeLocation = gl.getAttribLocation(program, "a_position");
        let timeUniformLocation = gl.getUniformLocation(program, "u_time");

        // Set up vertex data
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = [
            -1, 1,
            -1, -1,
            1, 1,
            1, -1,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        // Render loop
        let time = 0;

        function render() {
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);
            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

            gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

            gl.uniform1f(timeUniformLocation, time);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            time += 0.01;

            requestAnimationFrame(render);
        }
        render();

        // Navigation functions
        function navigateToGame() {
            animateButtonAndNavigate('.play-button', 'https://partlydecent.github.io/GAMEHUBORDINARY/game.html');
        }

        function navigateToVideoPlayer() {
            animateButtonAndNavigate(document.querySelectorAll('.play-button')[1], 'https://partlydecent.github.io/GAMEHUBORDINARY/videoPlayer.html');
        }

        function navigateToLiquidMusic() {
            animateButtonAndNavigate(document.querySelectorAll('.play-button')[2], 'https://partlydecent.github.io/GAMEHUBORDINARY/liquidMusic.html');
        }

        function navigateToDimension88() {
            animateButtonAndNavigate(document.querySelectorAll('.play-button')[3], 'https://partlydecent.github.io/GAMEHUBORDINARY/dimension88.html');
        }

        function navigateToAI() {
            animateButtonAndNavigate('.ai-button', 'https://partlydecent.github.io/GAMEHUBORDINARY/ai.html');
        }

        function animateButtonAndNavigate(selector, url) {
            try {
                const button = typeof selector === 'string' ? document.querySelector(selector) : selector;
                const warp = document.createElement('div');
                warp.classList.add('warp-distortion');
                document.body.appendChild(warp);
                
                // Use preloaded audio and handle failures gracefully
                try {
                    warpSound.currentTime = 0; // Reset audio to start
                    warpSound.play().catch(e => console.log('Audio play failed:', e));
                } catch (e) {
                    console.log('Audio error:', e);
                }

                button.style.transform = 'scale(0.9)';
                setTimeout(() => {
                    button.style.transform = 'scale(1)';
                    setTimeout(() => {
                        window.location.href = url;
                    }, 500);
                }, 100);
            } catch (e) {
                console.error('Navigation error:', e);
                // Fallback direct navigation if animation fails
                window.location.href = url;
            }
        }

        // Console input handling
        function handleConsoleInput(event) {
            if (event.key === 'Enter') {
                const input = event.target.value.toLowerCase();
                const easterEggs = {
                    'ali3n': 'easteregg.html',
                    'zombie1': 'egg1.html',
                    'valve2': 'egg2.html',
                    'unr3al': 'egg3.html',
                    'phant0m': 'egg4.html',
                    'shadow5': 'egg5.html',
                    'glitchx': 'egg6.html',
                    'oblivion7': 'egg7.html',
                    'cyb3rpunk': 'egg8.html',
                    'n3on9': 'egg9.html',
                    'matrix10': 'egg10.html',
                    'quantum11': 'egg11.html',
                    'nebula12': 'egg12.html',
                    'vortex13': 'egg13.html',
                    'enigma14': 'egg14.html',
                    'paradox15': 'egg15.html',
                    'synapse16': 'egg16.html',
                    'zenith17': 'egg17.html',
                }

                // Update shader code if command starts with "shader "
                if (input.startsWith('shader ')) {
                    const newShaderCode = input.substring(7);
                    updateShader(newShaderCode);
                } else if (easterEggs[input]) {
                    // Use absolute paths for easter eggs
                    window.location.href = 'https://partlydecent.github.io/GAMEHUBORDINARY/' + easterEggs[input];
                } else {
                    alert('UNKNOWN COMMAND: ' + input);
                }
                event.target.value = '';
            }
        }

        // Function to update the fragment shader
        function updateShader(newShaderCode) {
            try {
                const newFragmentShaderSource = `
                  precision mediump float;
                  uniform float u_time;
                  void main() {
                    ${newShaderCode}
                  }
                `;

                // Create new shader
                const newFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, newFragmentShaderSource);
                if (!newFragmentShader) return;

                // Create new program
                const newProgram = createProgram(gl, vertexShader, newFragmentShader);
                if (!newProgram) {
                    gl.deleteShader(newFragmentShader);
                    return;
                }

                // Delete old shader and program
                gl.deleteShader(fragmentShader);
                gl.deleteProgram(program);

                // Update shader and program
                fragmentShader = newFragmentShader;
                program = newProgram;

                // Update attribute and uniform locations
                positionAttributeLocation = gl.getAttribLocation(program, "a_position");
                timeUniformLocation = gl.getUniformLocation(program, "u_time");

                // Restart render loop if necessary
                time = 0;
            } catch (e) {
                console.error('Shader update error:', e);
            }
        }

        // Initial raymarching shader
        updateShader(`
// Constants for raymarching
const int MAX_STEPS = 100;
const float MAX_DIST = 100.0;
const float SURF_DIST = 0.001;

// SDF (Signed Distance Field) for a sphere
float sdSphere(vec3 p, float r) {
    return length(p) - r;
}

// SDF for a box
float sdBox(vec3 p, vec3 b) {
    vec3 d = abs(p) - b;
    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);
}

// SDF for a torus
float sdTorus(vec3 p, vec2 t) {
    vec2 q = vec2(length(p.xz) - t.x, p.y);
    return length(q) - t.y;
}

// Simple smooth minimum function for blending shapes
float smin(float a, float b, float k) {
    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
    return mix(b, a, h) - k * h * (1.0 - h);
}

// Main scene distance function
float getSceneDistance(vec3 p) {
    // Animate position based on time
    vec3 spherePos = vec3(sin(u_time) * 2.0, cos(u_time * 0.5) * 1.5, 0.0);
    vec3 boxPos = vec3(-2.0, sin(u_time) * 1.0, cos(u_time) * 2.0);
    
    // Define primitives
    float sphere = sdSphere(p - spherePos, 1.0);
    float box = sdBox(p - boxPos, vec3(0.8));
    float torus = sdTorus(p - vec3(1.5, 0.0, 2.0), vec2(1.0, 0.3));
    
    // Breathing animation effect
    float pulse = 0.5 + 0.5 * sin(u_time * 0.5);
    sphere *= mix(0.8, 1.2, pulse);
    
    // Combine shapes with smooth blending
    float d = smin(sphere, box, 1.0);
    d = smin(d, torus, 1.0);
    
    // Ground plane
    float ground = p.y + 1.5;
    
    return min(d, ground);
}

// Get the normal at point p
vec3 getNormal(vec3 p) {
    float d = getSceneDistance(p);
    vec2 e = vec2(0.001, 0.0);
    
    vec3 n = d - vec3(
        getSceneDistance(p - e.xyy),
        getSceneDistance(p - e.yxy),
        getSceneDistance(p - e.yyx)
    );
    
    return normalize(n);
}

// Raymarching function
float raymarch(vec3 ro, vec3 rd) {
    float dO = 0.0;
    
    for(int i = 0; i < MAX_STEPS; i++) {
        vec3 p = ro + rd * dO;
        float dS = getSceneDistance(p);
        dO += dS;
        if(dS < SURF_DIST || dO > MAX_DIST) break;
    }
    
    return dO;
}

// Main function body
vec2 uv = gl_FragCoord.xy / vec2(800.0, 600.0);
uv = uv * 2.0 - 1.0;
uv.x *= 800.0 / 600.0; // Aspect ratio correction

// Camera setup
vec3 ro = vec3(0.0, 0.0, -5.0); // Ray origin (camera position)
vec3 rd = normalize(vec3(uv, 1.0)); // Ray direction

// Rotate camera around the scene
float camAngle = u_time * 0.3;
mat2 camRotation = mat2(cos(camAngle), -sin(camAngle), sin(camAngle), cos(camAngle));
ro.xz = camRotation * ro.xz;
rd.xz = camRotation * rd.xz;

// Perform raymarching
float d = raymarch(ro, rd);

// Initialize color to background gradient
vec3 color = mix(
    vec3(0.1, 0.2, 0.3), // Darker tech color from original
    vec3(1.0, 0.8, 0.5), // Lighter warm tech tone from original
    max(0.0, 1.0 - d * 0.06) // Fade out with distance
);

// If we hit something
if(d < MAX_DIST) {
    vec3 p = ro + rd * d; // Point position
    vec3 n = getNormal(p); // Surface normal
    
    // Lighting
    vec3 lightDir = normalize(vec3(1.0, 2.0, 3.0));
    float diffuse = max(0.0, dot(n, lightDir));
    
    // Pulse effect from original shader
    float pulse = 0.5 + 0.5 * sin(u_time * 0.5);
    float pulseEffect = sin(u_time * 0.3) * 0.2 + 0.8;
    
    // Apply lighting and effects to color
    color = mix(
        vec3(0.1, 0.2, 0.3), // Dark color
        vec3(1.0, 0.8, 0.5), // Light color
        diffuse * pulse    // Lighting affected by pulse
    );
    
    // Add ambient occlusion approximation
    float ao = clamp(p.y + 1.5, 0.0, 1.0);
    color *= mix(0.5, 1.0, ao);
    
    // Apply pulse effect to final color
    color *= pulseEffect;
}

// Vignette effect (darkening around edges)
float vignette = 1.0 - dot(uv * 0.5, uv * 0.5);
color *= vignette;

// Output final color
gl_FragColor = vec4(color, 1.0);
`);

        // Resize canvas on window resize
        window.addEventListener('resize', () => {
            webglCanvas.width = window.innerWidth;
            webglCanvas.height = window.innerHeight;
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        });
    </script>
</body>

</html>

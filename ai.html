<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Neural Interface & Alien Chat</title>
  <style>
    /* Global Styles */
    body {
      margin: 0;
      padding: 0;
      background: #0a0a1a;
      font-family: 'Arial', sans-serif;
      display: flex;
      height: 100vh;
      overflow: hidden;
    }
    /* Neural Visualizer (Left) */
    #neuralCanvas {
      flex: 1;
      background: radial-gradient(circle at center, #020210 0%, #000000 100%);
    }
    /* Alien Chat Container (Right) */
    #chatContainer {
      width: 300px;
      background: #1a1a1a;
      border-left: 2px solid #e74c3c;
      padding: 15px;
      height: 100vh;
      box-shadow: -5px 0 15px rgba(0, 0, 0, 0.5);
      display: flex;
      flex-direction: column;
      color: #e0e0e0;
    }
    #chatContainer h2 {
      margin: 0 0 10px 0;
      font-size: 1.2em;
      text-transform: uppercase;
      letter-spacing: 2px;
      color: #e74c3c;
    }
    #chatbox {
      flex: 1;
      overflow-y: auto;
      background: #111;
      border: 1px solid #333;
      padding: 8px;
      font-size: 0.9em;
      line-height: 1.3em;
    }
    #chatbox p {
      margin: 5px 0;
      padding: 4px 6px;
    }
    #chatbox p.bot {
      color: #3498db;
      background: rgba(52,152,219,0.1);
      border-left: 3px solid #3498db;
    }
    #chatbox p.user {
      color: #e0e0e0;
      background: rgba(231,76,60,0.1);
      border-left: 3px solid #e74c3c;
    }
    #inputField {
      width: 100%;
      padding: 8px 10px;
      font-size: 1em;
      border: 1px solid #333;
      border-radius: 4px;
      background: #111;
      color: #e0e0e0;
      margin-top: 10px;
    }
    #inputField:focus {
      outline: none;
      border-color: #e74c3c;
      box-shadow: 0 0 8px #e74c3c;
    }
    /* Button Styles */
    button {
      padding: 8px 12px;
      font-size: 0.9em;
      margin: 5px 2px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      background: #e74c3c;
      color: #fff;
      transition: background 0.3s;
    }
    button:hover {
      background: #c0392b;
    }
    /* Terrain Button (floating) */
    #terrainBtn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: #27ae60;
      padding: 10px 20px;
      border-radius: 25px;
      font-size: 0.9em;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
      z-index: 1000;
    }
  </style>
</head>
<body>
  <!-- Neural Visualizer -->
  <canvas id="neuralCanvas"></canvas>
  
  <!-- Chat Interface -->
  <div id="chatContainer">
    <h2>Umbrella Chat</h2>
    <div id="chatbox"></div>
    <input id="inputField" type="text" placeholder="Transmit your message..." />
    <div>
      <button onclick="downloadState()">Download Memory</button>
      <input type="file" id="fileInput" accept=".json" onchange="uploadState(event)" style="display: none;" />
      <button onclick="document.getElementById('fileInput').click()">Upload Memory</button>
    </div>
  </div>
  
  <!-- Terrain Button -->
  <button id="terrainBtn" onclick="window.open('terrain.html', 'Terrain Generator', 'width=600,height=400')">
    Terrain
  </button>
  
  <!-- Audio for Bot Message -->
  <audio id="Otc1" src="chat.mp3"></audio>
  
  <script>
    /* ===== Neural Visualizer Code ===== */
    const canvas = document.getElementById('neuralCanvas');
    const ctx = canvas.getContext('2d');
    let nodes = [];
    let connections = [];
    
    class NeuralNode {
      constructor(x, y, layer) {
        this.x = x;
        this.y = y;
        this.layer = layer;
        this.activation = 0;
      }
    }
    
    function resizeCanvas() {
      // Reserve 300px for chat panel
      canvas.width = window.innerWidth - 300;
      canvas.height = window.innerHeight;
      initVisualizer();
    }
    
    function initVisualizer() {
      nodes = [];
      connections = [];
      const layers = 5;
      const nodeCounts = [5, 7, 9, 7, 5];
      const layerPositions = Array.from({ length: layers }, (_, i) =>
        canvas.width * 0.1 + (i * canvas.width * 0.8 / (layers - 1))
      );
      
      nodeCounts.forEach((count, layer) => {
        const yStep = canvas.height / (count + 1);
        for (let i = 0; i < count; i++) {
          nodes.push(new NeuralNode(layerPositions[layer], yStep * (i + 1), layer));
        }
      });
      
      // Create more dynamic random connections
      nodes.forEach(source => {
        nodes.forEach(target => {
          if (source.layer < target.layer && Math.random() > 0.5) {
            connections.push({
              source,
              target,
              strength: Math.random(),
              phase: Math.random() * Math.PI * 2
            });
          }
        });
      });
    }
    
    function animate() {
      ctx.fillStyle = '#020210';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw connections with a pulsating effect
      connections.forEach(conn => {
        ctx.beginPath();
        ctx.moveTo(conn.source.x, conn.source.y);
        ctx.lineTo(conn.target.x, conn.target.y);
        const alpha = 0.3 + (Math.sin(conn.phase) * 0.2);
        ctx.strokeStyle = `rgba(52,152,219,${alpha})`;
        ctx.lineWidth = 2 + (conn.strength * 4);
        ctx.stroke();
        conn.phase += 0.03;
      });
      
      // Draw nodes with glow & pulsation based on activation
      nodes.forEach(node => {
        ctx.save();
        ctx.shadowColor = '#3498db';
        ctx.shadowBlur = 15 + (node.activation * 30);
        const size = 6 + (node.activation * 6) + Math.sin(Date.now()/200 + node.x)*1.5;
        ctx.fillStyle = '#3498db';
        ctx.beginPath();
        ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        // Gradually reduce activation
        node.activation *= 0.95;
      });
      
      requestAnimationFrame(animate);
    }
    
    // Make the neural net "feel" actions: mouse move, clicks, key presses
    function activateNodesNear(x, y, radius = 50) {
      nodes.forEach(node => {
        const dx = node.x - x;
        const dy = node.y - y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < radius) {
          node.activation = Math.min(1, node.activation + (1 - dist / radius));
        }
      });
    }
    
    // Random activation for general actions
    function activateRandomNode() {
      if (nodes.length > 0) {
        const randomIndex = Math.floor(Math.random() * nodes.length);
        nodes[randomIndex].activation = 1;
      }
    }
    
    // Global event listeners for site activity
    document.addEventListener('mousemove', (e) => {
      // Only affect the canvas area
      if (e.clientX < canvas.width) {
        activateNodesNear(e.clientX, e.clientY);
      }
    });
    document.addEventListener('click', () => {
      activateRandomNode();
    });
    document.addEventListener('keydown', () => {
      activateRandomNode();
    });
    
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    animate();
    
    /* ===== Chatbot Code ===== */
    let state = {
      messages: [],
      nodes: { default: [] }
    };
    
    function loadState() {
      const saved = localStorage.getItem('chatbot_state');
      if (saved) {
        state = JSON.parse(saved);
        renderChat();
      }
    }
    
    function saveState() {
      localStorage.setItem('chatbot_state', JSON.stringify(state));
    }
    
    function renderChat() {
      const chatbox = document.getElementById('chatbox');
      chatbox.innerHTML = state.messages
        .map(msg => {
          let cls = '';
          if (msg.startsWith('Bot:')) cls = 'bot';
          else if (msg.startsWith('You:')) cls = 'user';
          return `<p class="${cls}">${msg}</p>`;
        })
        .join('');
      chatbox.scrollTop = chatbox.scrollHeight;
    }
    
    function addMessage(msg) {
      state.messages.push(msg);
      renderChat();
      // If it's a bot message, play sound and trigger visual reaction
      if (msg.startsWith('Bot:')) {
        document.getElementById('Otc1').play().catch(e => console.log(e));
        activateRandomNode();
      }
    }
    
    function addNode(triggerPattern, responseText) {
      const newNode = { trigger: new RegExp(triggerPattern, 'i'), response: responseText };
      if (!state.nodes.default) state.nodes.default = [];
      state.nodes.default.push(newNode);
      saveState();
      addMessage(`System: New node added with trigger "${triggerPattern}"`);
    }
    
    function processInput(input) {
      if (input.startsWith('ADD NODE:')) {
        const parts = input.substring(9).split(',');
        let triggerPart = parts.find(part => part.trim().toLowerCase().startsWith('trigger='));
        let responsePart = parts.find(part => part.trim().toLowerCase().startsWith('response='));
        if (triggerPart && responsePart) {
          const trigger = triggerPart.split('=')[1].trim();
          const response = responsePart.split('=')[1].trim();
          addNode(trigger, response);
          return;
        } else {
          addMessage("System: Invalid ADD NODE format. Use: ADD NODE: trigger=your_trigger, response=your_response");
          return;
        }
      }
      processAdvancedInput(input);
    }
    
    function processAdvancedInput(input) {
      let responded = false;
      state.nodes.default.forEach(node => {
        if (node.trigger.test(input) && !responded) {
          addMessage(`Bot: ${node.response}`);
          responded = true;
        }
      });
      if (!responded) {
        addMessage("Bot: I don't know how to respond. Teach me with ADD NODE: trigger=..., response=...");
      }
      saveState();
    }
    
    document.getElementById('inputField').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const userInput = e.target.value.trim();
        if (userInput) {
          addMessage(`You: ${userInput}`);
          activateRandomNode();
          processInput(userInput);
        }
        e.target.value = '';
      }
    });
    
    function downloadState() {
      const blob = new Blob([JSON.stringify(state)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = 'chatbot_state.json';
      link.click();
      URL.revokeObjectURL(url);
    }
    
    function uploadState(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        try {
          state = JSON.parse(reader.result);
          saveState();
          renderChat();
          addMessage('System: State uploaded successfully.');
        } catch (e) {
          addMessage('System: Invalid JSON format.');
        }
      };
      reader.readAsText(file);
    }
    
    loadState();
    if (state.messages.length === 0) {
      addMessage("Bot: Greetings, human. I am Otc1.");
      addMessage("Bot: Instruct me with: ADD NODE: trigger=your_trigger, response=your_response");
    }
  </script>
</body>
</html>
